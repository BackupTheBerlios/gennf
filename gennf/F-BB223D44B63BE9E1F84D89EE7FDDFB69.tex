\documentclass[fleqn, 10pt, a4paper]{article}
\usepackage{amssymb}
\setlength{\parindent}{0pt}

\begin{document}
\title{\emph{Scratchpad}\\
{\scshape Infrastructures for Open Source Software Development}\\
Distributed Version Management System with Code Signing}
\maketitle

\tableofcontents

\section{Prologue}
This document is our project's scratchpad accompanying the development
of a distributed version management system enhanced with code signing as
part of the \emph{Infrastructures for Open Source Software Development}
course held by Steffen Evers at the Berlin Technical University.

Our hope is, that eventually the project's documentation will be
distilled out of this text. Up to that point, it will be a bit messy,
probably unstructured and a moving target of course.

\section{Developers}
Development is currently planned to be undertaken by
\begin{itemize}
\item Fabian Otto, \texttt{sigsegv@cs.tu-berlin.de}
\item Hannes Mehnert, \texttt{mehnert@cs.tu-berlin.de}
\item Florian Lorenzen, \texttt{florenz@cs.tu-berlin.de}
\end{itemize}

\section{The goal}
We want to implement a better version management system based on
existing software. \emph{Better} in a sense that it supports
code signing and distributed repositories.

Code signing means, that each chunk of code checked into the repository
has to be signed by the programmer using some public/private key scheme
to enable other developers or users to verify the origin of the code (as
long as keys are trustworthy).

Distributed means that the repository is not stored on a single server
but that check ins can be done on several servers and the result be
merged. The advantages are a better failure behaviour and the
possibility to structure the repositories according to some external
requirements, e.~g. responsibilities for or maintenance of certain code
sections by certain parties.

Initially, we also thought about improving the code merging capabilities
which are geavily relied on in distributed environments. The idea was to
do a merge not of streams of characters (the source code) but of
abstract syntax trees of the programming language used. This seemd very
nnpromising because fewer conflicts should arise. We abandoned this plan
for several reasons:
\begin{itemize}
\item It is language dependant: for every language used in the code at
least a context free and a regular grammar are  required. To do the
lexing and parsing a lexer- and parser-generator or some function $\phi
: G_L \rightarrow G_P \rightarrow S \rightarrow T$ with $G_L$ being a
lexer grammar, $G_P$ a parser grammar, $S$ a source code and $T$ an
abstract syntax tree would have to be implemented. This is not something
impossible but takes quite some time.
\item The algorithm to compare two abstract syntax trees is not so
trivial, at least if something better than line based diffs is supposed
to come out. Another trouble is what to consider as a conflict.
\item How to store diffs of to trees? Our idea was to store functions
$\tau : T \rightarrow T$ which transform one tree into the other. Those
function could also be used to apply the changes. At this point the
question arose if $\tau_1 \circ \tau_2 \neq \tau_2 \circ \tau_1$ could
be used as the definition of a conflict. But this is probably to simple.
Those function $\tau_i$ in turn would be compositions of atomic
transformations of one node in the tree, i.~e. a combinataion of paths
in the tree and actions to be taken at the end of the path.
\item Preserving the code layout may be a problem, even with layout
annotations in the syntax trees.
\item What to use as the storage backend? Some line based store would
not really fulfil the needs because this meant to pretty-print the
syntax tree (using the layout annotations) and to parse the last checked in
version at each commit. Consequently, the transformation function
should be stored. This in the end lead to the decision to forget about
improving the merge because the best way to do it is to write something
completely new which is too much work for one semester.
\end{itemize}

\section{The plan}
We discussed improving the handling of repositories in \textsc{darcs} or
adding distributed repositories to \textsc{metacvs}. Code Signing is not
available in any of them (at least not in our sense).

We decided to build on \textsc{metacvs} because it is, in turn, based on
\textsc{cvs} which we know quite well and because it is written in
\textsc{Common~Lisp} which makes rapid development at least possible.

In the end we would of course like to integrate our development back
into \textsc{metacvs} if convenient for the \textsc{metacvs} developers.
Hence the \ldots

\subsection{Naming issue}
For the course of development, the \emph{thing} will be called
\textsc{gennf} just to have a name (gennf is the name of the gas emitted
by the time snails in Zamonia).

\subsection{Technical stuff}
\textsc{metacvs} is implemented in \textsc{clisp} which is now installed
in \texttt{/home/pub/bin} in the IRB-network. \textsc{metacvs} is
installed in the same location to get familiar with it and for testing
purposes. \textsc{metacvs} requires \texttt{libsigsegv}, which is
installed but I had to patch the \texttt{/home/pub/bin/mcvs}-script and
the install-script to have a proper \texttt{LD\_LIBRARY\_PATH}. The
patched sources (also for \textsc{clisp}) are in \texttt{/home/pub/src}.

\textsc{slime} is installed in \texttt{/home/pub/share/emacs/slime} and
can be used by putting
\begin{verbatim}
(add-to-list 'load-path "/home/pub/share/emacs/slime")
(require 'slime)
(slime-setup)
(setq inferior-lisp-program "clisp")
\end{verbatim}

into \texttt{\textasciitilde/.emacs}.

\subsection{Communication}
Everyone participating in the project is free to mess up this file to
record relevant thoughts, ideas, \ldots
Day-to-day communication will be done using
\texttt{gennf-devel@lists.berlios.de}.

There is a regular meeting tuesdays at 12 o'clock in the i-caf\'e if
not announced differently.

\subsection{Schedule \label{schedule}}
There is no real schedule yet but\ldots

\begin{tabular}{|p{.3\textwidth}|p{.6\textwidth}|}
\hline
\textmd{When} & \textmd{What} \\
\hline\hline
Nov. 7 &
Meeting at 12 o'clock in FR5017 to discuss design issues. \\
\hline
Nov. 4 to Nov. 15 &
Getting familiar with the code of \textsc{metacvs}
and drafting a design for distributiveness and signing. \\
\hline
\end{tabular}

\section{Code Signing}

\subsection{Motivation}
Currently most version management systems don't use any digital signatures
for code (apart from \textsc{tla}). Authentication is done by an own password
server (\textsc{cvs}: pserver), via a ssh public key (\textsc{cvs},
\textsc{subversion}, \textsc{darcs}, \textsc{metacvs}) or
via a digitally signed mail (\textsc{darcs}).

On the other hand, data integrity is not supported.
Every user has to trust the repository server
to be secure from a possible hacker breaking into it.
A hacker with access to the repository is able to compromise the
software by unperceived insert of a backdoor.

In the past, several big repositories have been hacked, including
KDE\footnote{http://seclists.org/lists/fulldisclosure/2004/May/0349.html},
sourceforge, jabber.org [TODO: add links].


\subsection{Vision}
A developer using \textsc{gennf} should be able to sign his patches via
an already known-to-work and widely deployed public key cryptosystem.

An auditor should be able to look at any number of parts of the code
and sign them digitally after a successful code audit.

A user checking out the code should be able to verify the code, looking
at the different trust levels of the lines of code.
He should be able to easily spot the lines
which are least trusted according to his web of trust. If he cares much
about security, he can audit those hot spots and sign them in the repository,
becoming an auditor.

So, the trust is moved from the single point of failure (the repository
server) to every developer (able to protect his private key, or otherwise
revoke his key).

\subsection{Workflows}
A possible workflow for the developer would be that he first starts coding,
fixing a bug or implementing a new feature. When he has done with that,
during the commit he'll be asked whether he wants to sign this commit.
If he chooses to sign, he is asked for the passphrase protecting
his private key. After successfully verification of the passphrase,
the commit will be signed and transferred to the server.
Authentication could probably also be done via the signature on the code,
so no user management is anymore needed on the server, only a public keyring
including all developer keys, but possibly anyone can commit, and the user
has to choose who to trust during checkout.

A user with access to the repository checking out can verify the checked
out code, and see how safe it is.
Via \texttt{metacvs blame} he should be able to look which lines are
at which trust levels.

Via \texttt{metacvs sign} a code auditor (or user) should be able to
sign parts of code (line-, file-based).

\subsection{Implementation overview}
\begin{itemize}
\item Public key cryptography interface for \textsc{clisp}.
\item Unique patchset number, like in subversion, to match a signature to a revision.
\item Virtual patchsets describing regions in source files for auditor.
\item Decide where to store signatures.
(I think, there should be a new meta file containg the signatures, what
lines and revisions they apply to. Putting it this way audits can be handled
in the same mannner. Change and audit signatures have to distinguished by
some tag. Storeing all this in a meta file makes audit signs an
ordinary check in operation on this file -- which should be wrapped in
a nice command of course. The same applies to normal commits: they
change the F-files and make a change to the new meta file. [Florian])
\item Integration in \textsc{metacvs} commands like \texttt{commit},
\texttt{checkout}, \texttt{blame}.
\item Implement more \textsc{metacvs} commands like \texttt{verify},
\texttt{sign}.
\end{itemize}

\subsection{Implementation detail}
OpenPGP will be used as pulic key cryptosystem, because it has an
open-source implementation \textsc{gpg} (GNU Privacy Guard), is not
hierarchically structured due to the web of trust and keyserver rings.
It is also widely deployed in open source developer communities.

It has a \texttt{GnuPG Made Easy} \textsc{gpgme} development library,
which needs to be wrapped in a C-Interface for \textsc{clisp}.

The signatures has to be stored somewhere in \textsc{metacvs}, probably
in the metadata.

Some parts should be configurable for \textsc{metacvs} code signing,
a default key ID for the developer, a public keyring file for authentication
on the repository server, and possibly other things.

Probably an \textsc{emacs}-integration for \textsc{metacvs}, including the
audit-part, would be useful.


\section{Distributed repositories}

\subsection{Outline}

By support for \emph{distributed repository} we mean support for the following
features:

\begin{itemize}
\item \textsc{gennf} will provide a possibility to \emph{inherit} from an
already existing repository which means to create a branch
at another site. It is not necessary for this new site to store the
whole history of the project: \textsc{gennf} will establish a link between the two.
Whenever someone at the new repository requests a version not locally
available, it will be fetched from the original site. It is of course
possible to replicate large parts of or the whole history to improve
performance or redundancy. However, duplicated parts of the history still
know where they come from.

\item The different lines of development can be merged together, of course.
\textsc{gennf} keeps track of the origin of the code merged in. The mechanism
of merge is used to create branches, too. In fact, a merge is the only
basic operation \textsc{gennf} knows about, apart from ordinary changes (which
do not come from another site but out of some developer's head).
Both -- changes and merges -- are called commits.
\end{itemize}


\subsection{Modelling distributiveness}

In the following section I propose an abstract model for distributed
repositories and their interaction. It is still incomplete
especially concerning sandbox-repository interaction but gives already
some implementation hints.

\subsubsection{The basic notions: Repository, branch and commit}

A \emph{repository} $r$ for a certain project is the set of development
branches the project consists of.

A \emph{branch} $b$ is an ordered pair $[\beta, s]$ with $\beta$ being
a \emph{branch identifier} and $s$ being
a sequence of commits.

A \emph{commit} $c$ is the building block of repositories.
Addition of commits to a repository is the basic modification
of repositories.

A commit can be a change or a merge.

A \emph{change} is a 4-tuple $[\nu, \beta, \alpha, f]$ with
\begin{itemize}
\item $\nu$ being the branch-unique commit-number,
\item $\beta$ being the branch identifier of the branch
this commit belongs to,
\item $\alpha$ being an access identifier and
\item $f$ being a map $\mathnormal{filename} \rightarrow
\mathnormal{revision\_number}$.
\end{itemize}

The domain of $f$ is the set of files modified by a certain
commit $c$. $f(\mathtt{file})$ is the revision-number the
backend assigned to \texttt{file}, which is necessary to
retrieve the state of \texttt{file} at checkin time of $c$.

The \emph{access identifier} $\alpha$ is an abstraction layer for the
backend. This includes things like hostname and path where the
repository is stored, the corresponding authentication method
and functions to checkin and -out files to and from this backend.

A \emph{merge} is a change with two ancestors:
One is its predecessing commit in the same branch the merge
goes to. The second one is the commit being merged in which is
called \emph{origin} of the merge.

The origin of a merge was a change at some
point in history to another branch. Consequently, a merge $m$ is
a 5-tuple $[\nu, \beta, \alpha, f, o]$. The first four elements
have the same meaning as in a change, the fifth links this commit
to its origin.

The origin $o$ is a 4-tuple $[\nu, \beta, \alpha, d]$. The meaning
of $\nu$, $\beta$, $\alpha$ is the same as for changes. But
in this case they establish a link to a (possibly remote)
commit with number $\nu$
on branch $\beta$ reachable via access identifier $\alpha$.

$d$ indicates if the change-part of a merge \emph{d}uplicates
the change part of its origin. In this case traversing history
along the merge's branch leads to the same result as traversing
the origin's history -- at least for the one commit.
This feature is useful as merges are used for inheritance, i.~e.
duplication. It is not necessary for inheritance to work but
is convenient as it indicates that traversing the origin's history
is the same as traversing the merge's history.

\subsubsection{Properties of the basic notions}

The following helper functions are introduced for brevity:

\begin{itemize}
\item $\mathnormal{nu}:\ \mathnormal{branch} \rightarrow \mathbb{N}$ \\
The number of a branch (its identifier).
\item $\mathnormal{ma}:\ \mathnormal{branch} \rightarrow \mathnormal{filename}$ \\
Returns the name of the map file for this branch. More on map files follows in
a later section.
\item $\mathnormal{sy}:\ \mathnormal{branch} \rightarrow \mathnormal{string}$ \\
A symbolic name for this branch.
\item $\mathnormal{de}:\ \mathnormal{branch} \rightarrow \mathnormal{string}$ \\
A description of this branch.
\item $\mathnormal{nu}:\ \mathnormal{commit} \rightarrow \mathbb{N}$ \\
The number of a commit.
\item $\mathnormal{br}:\ \mathnormal{commit} \rightarrow \mathnormal{branch\_identifier}$ \\
The branch identifier of the branch the commit belongs to.
\item $\mathnormal{ac}:\ \mathnormal{commit} \rightarrow \mathnormal{access\_identifier}$ \\
The access identifier of the commit.
\item $\mathnormal{fi}:\ \mathnormal{commit} \rightarrow (\mathnormal{filename}
\rightarrow \mathnormal{revision\_number})$ \\
The filename-revision-map of this commit.
\item $\mathnormal{oi}:\ \mathnormal{merge} \rightarrow \mathnormal{origin}$ \\
The origin of the merge.
\item $\mathnormal{nu}:\ \mathnormal{origin} \rightarrow \mathbb{N}$ \\
The origin's commit-number.
\item $\mathnormal{br}:\ \mathnormal{origin} \rightarrow \mathnormal{branch\_identifier}$ \\
The origin's branch identifier.
\item $\mathnormal{ac}:\ \mathnormal{origin} \rightarrow \mathnormal{access\_identifier}$ \\
How to access the origin (its access identifier).
\item $\mathnormal{du}:\ \mathnormal{origin} \rightarrow \mathbb{B}$ \\
The duplication identifier. If $\mathnormal{du}(o) = \mathtt{true}$
histories are equal. In general it is $\mathtt{false}$.
\end{itemize}

This abbreviation is used for merges:

$\hat c = [\nu', \beta', \alpha', f', o]$ with $o=[\nu, \beta, \alpha, d]$ and
$c=[\nu, \beta, \alpha, f]$. That means $\hat c$ is the result of mergeing
commit $c$ to some other branch $\beta'$.

Now follow important properties for repositories and their elements.

A repository $r$ is a set of branches:

\begin{displaymath}
r = \{b \ |\ b\ \mbox{\textsc{isa}}\ \mathnormal{branch}\}
\end{displaymath}

Branch numbers must be unique:

\begin{displaymath}
\forall b_1, b_2 \in r:\, \mathnormal{nu}\ b_1 \neq \mathnormal{nu}\ b_2
\end{displaymath}

A branch $b$ is a sequence of commits, which all belong to
$b$ and are accessible in the same way:

\begin{displaymath}
b\ \mbox{\textsc{isa}}\ \mathnormal{commit}\ \mathnormal{sequence}\ \wedge\
\forall c_1, c_2 \in b:\, \mathnormal{br}\ c_1 = \mathnormal{br}\ c_2\ \wedge
\mathnormal{ac}\ c_1 = \mathnormal{ac}\ c_2
\end{displaymath}

Commit numbers in a branch must be unique:

\begin{displaymath}
\forall c_1, c_2 \in b:\, \mathnormal{nu}\ c_1 \neq
\mathnormal{nu}\ c_2
\end{displaymath}

\subsubsection{Operations on repositories}

The effect of basic operations is described below. $r$ is an
existing repository and initially looks like this:
$r = \{[\beta, \langle c_1, c_2, c_3, \ldots, c_n\rangle]\}$

The following notations are used:

\begin{itemize}
\item $c \rhd c'$: $c$ is merged in $c'$.
\item $\triangledown c$: A branch from $c$ is created, i.~e. $c \rhd \emptyset$
is performed with $\emptyset$ being the empty branch.
\item $\underline\triangledown_n c$: A branch from $c$ is created including $n$
predecessors of $c$. $\underline\triangledown_0 c$ is equivalent to
$\triangledown c$.
An operation $\underline\triangledown_n c$ with $n>0$ is called inheriting from c.
If all predecessors of $c$ are inherited this is denoted
by $\underline\triangledown_\star$
and called total inheritance and in fact is duplication. A
$\underline\triangledown_n$ operation is the only one to cause
$\mathnormal{du}(\hat c)\neq \mathtt{false}$. For convenience,
$d$ is always false if not mentioned in the tuple $o$ ($[\nu, \beta, \alpha,
\mathtt{false}]=[\nu, \beta, \alpha]$)
or indicated otherwise.
\end{itemize}

The basic operations inherit, branch, merge are ``defined'' by the
following transitions:	

\begin{itemize}
\item The empty repository $r'=\{\}$ \emph{inherits} the whole repository $r$
($\underline\triangledown_\star c_n$):

$r' = \{[\beta', \langle m'_1, m'_2, m'_3, \ldots, m'_n\rangle]\}$ with
$m'_i = [\nu'_i, \beta'_i, \alpha'_i, f'_i, \hat c_i]$ (as reminder:
$\hat c_i = [\nu_i, \beta_i, \alpha_i, \mathtt{true}]\
\wedge\ c_i=[\nu_i, \beta_i, \alpha_i, f]$, note $\forall
\hat c_i:\, \mathnormal{du}(d_i)=\mathtt{true}$).

\item $r'$ \emph{inherits parts} of the repository ($\underline\triangledown_
{n-k}c_k$):

$r'=\{[\beta', \langle m'_1, m'_2, m'_3, \ldots, m'_{n-k}, m'_{n-k+1}\rangle]\}$ with
$m'_i=[\nu'_i, \beta'_i, \alpha'_i, f, \hat c_{i+k-1}]$ and
$c_{i}=[\nu_i, \beta_i, \alpha_i, f_i]$, $k<n$.

\item Create a \emph{branch} from a commit $c_k$ inside $r$
($\triangledown c_k$):

$r = \{[\beta, \langle c_1, \ldots, c_k, \ldots, c_n\rangle], [\beta^2, \langle m_1^2
\rangle]\}$ with $m_1^2=[\nu_1^2, \beta_1^2, \alpha_1^2, f_1^2, \hat c_k]$ and
$\mathnormal{du}(\hat c_k)=\mathtt{false}$.	

After doing some commits to the new branch the repository looks like

$r = \{[\beta, \langle c_1, \ldots, c_k, \ldots, c_n\rangle], [\beta^2, \langle m_1^2,
c_2^2, c_3^2, \ldots, c_m^2\rangle ]\}$

\item Inside $r$, the heads of two branches are \emph{merged}
($c_n^1 \rhd
 c_m^2$):

Before the merge, the repository has this form:

$\{[\beta^1, \langle c_1^1, c_2^1, \ldots, c_n^1\rangle],
[\beta^2, \langle c_1^2, c_2^2, \ldots, c_m^2\rangle]\}$	

After the merge, branch $b^2$ has one more commit:

$\{[\beta^1, \langle c_1^1, c_2^1, \ldots, c_n^1\rangle],
[\beta^2, \langle c_1^2, c_2^2, \ldots, c_m^2, m_{m+1}^2\rangle]\}$

with $m_{m+1}^2=[\nu_{m+1}^2, \beta_{m+1}^2, \alpha_{m+1}^2, f_{m+1}^2,
\hat c_n^1]$

It is obvious that the result looks the same when commits
from different repositories are merged. Given

$r = \{[\beta, \langle c_1, c_2, c_3, \ldots, c_n\rangle]\}$ and \\
$r' = \{[\beta', \langle c'_1, c'_2, c'_3, \ldots, c'_m\rangle]\}$,

merging their heads $c'_m \rhd c_n$ leads to one more commit in
$r$:

$r = \{[\beta, \langle c_1, c_2, c_3, \ldots, c_n, m_{n+1}\rangle]\}$
with a link $\hat c'_m$ as last element in $m_{n+1}$.
\end{itemize}


\subsubsection{How to store branches}

\textsc{metacvs} introduces F-files. They are called F-files
because their names start with an ``F'' followed by a dash and
32 randomly generated hexadecimal digits. The name of an F-file
is the unique identifier for a file which is under \textsc{metacvs}'s
control.

\textsc{metacvs} introduces a mapping $\mathnormal{F\_file}
\rightarrow filename$ to map the unique identifiers to
a ``physical'' filename. This map ist stored in a file
called \texttt{MAP} which has the format:

\begin{verbatim}
(mapping*)
\end{verbatim}


A \texttt{mapping} is a list which stores the F-filename,
the ``physical'' filename and meta information like
executable state of the file:

\begin{verbatim}
(:KEY
 "F-filename"
 "filename"
 (meta-information))
\end{verbatim}

\texttt{:KEY} can be \texttt{:FILE} indicating that \texttt{filename}
is an ordinary file or \texttt{:LINK} to version symbolic links.

The main goal of the \texttt{MAP}-file is to resolve the
trouble \textsc{cvs} has with directories and file moves. The entire
project hierarchy is flattened (my guess is that the ``F'' in
the F-files stands for \emph{flat}) and structure is provided
by the \texttt{MAP}-file.

A project $p$ may have a structure like
\begin{displaymath}
\begin{array}{l}
p/ \\
\qquad d_1/ \\
\qquad\qquad f_{11} \\
\qquad\qquad f_{12} \\
\qquad\qquad \vdots \\
\qquad\qquad f_{1k} \\
\qquad \vdots \\
\qquad d_m/ \\
\qquad\qquad f_{m1} \\
\qquad\qquad \vdots \\
\qquad\qquad f_{ml}
\end{array}
\end{displaymath}

This leads to a \texttt{MAP}-file as follows -- the $a$, $b$, $c$,
\ldots are randomly generated numbers:
\begin{displaymath}
\begin{array}{l@{}l}
\mathtt{((} & \mathtt{:KEY} \\
            & \mathtt{"MCVS/F-}a \mathtt{"} \\
            & \mathtt{"}d_1/f_{11}\mathtt{")} \\
\mathtt{(}  & \mathtt{:KEY} \\
            & \mathtt{"MCVS/F-}b \mathtt{"} \\
            & \mathtt{"}d_1/f_{12}\mathtt{")} \\
            & \vdots \\
\mathtt{(}  & \mathtt{:KEY} \\
            & \mathtt{"MVCS/F-}c \mathtt{"} \\
            & \mathtt{"}d_1/f_{1k}\mathtt{")} \\
            & \vdots \\
\mathtt{(}  & \mathtt{:KEY} \\
            & \mathtt{"MCVS/F-}d \mathtt{"} \\
            & \mathtt{"}d_m/f_{m1}\mathtt{")} \\
	    & \vdots \\
\mathtt{(}  & \mathtt{:KEY} \\
            & \mathtt{"MCVS/F-}e \mathtt{"} \\
            & \mathtt{"}d_m/f_{ml}\mathtt{"))} \\
\end{array}
\end{displaymath}

The reason that all F-file paths are prepended by
\texttt{MCVS} is that \textsc{metacvs} stores its
administrative information in a directory \texttt{MCVS}
inside the project directory -- like \texttt{cvs} does
with its \texttt{CVS} directory. The \texttt{MCVS}
directory keeps all F-files.

The trick is to hard link the F-files into the project's
sandbox according to the \texttt{MAP}-file. Now moving or
renaming files is done with \textsc{metacvs} command which
rename the hard links and modify the mappings. A move conflict
appears as a conflict in the \texttt{MAP}-file.

As gotcha, \texttt{MAP} enables version control of links and
additional bits like the executable bit.

In later sections the \texttt{MAP}-file will be shown as a
a map -- omitting the \texttt{MCVS}-path-prefix and quotation
marks -- like this:
\begin{displaymath}
\mathtt{MAP} =\left[
\begin{array}{lcl}
\mathtt{F-}a &\mapsto& d_1/f_{11} \\
\mathtt{F-}b &\mapsto& d_1/f_{12} \\
             &\vdots & \\
\mathtt{F-}c &\mapsto& d_1/f_{1k} \\
\mathtt{F-}d &\mapsto& d_m/f_{m1} \\
             &\vdots & \\
\mathtt{F-}e &\mapsto& d_m/f_{ml} \\
\end{array}\right]
\end{displaymath}

The idea to implement branches is to have one \texttt{MAP} file
for each branch to store which files belong to this branch and what
their ``physical name'' is. This way, all files are stored without
any hierarchy. There is one constraint: The identifier in the
F-file may not change from branch to branch. If it did, one
needed another mapping from trunk- to branch-F-files. If not done
so it would be impossible to track down the origin of a file in
a branch which made merging impossible.

Hence, it is easiest to let the F-filenames be invariant. As it is
impossible to have two files of the same name in one directory the
branch identifier $\beta$ is appended to the F-filename. At this
point, we should track down branch identifiers to $\mathbb{N}$
such that possible names of F-files are $\mathtt{F-}a\mathtt{.}\beta$
with $\beta\in \mathbb{N}$. The same branch identifier is appended
to the branch's \texttt{MAP}-file. This way, all files of
branch $b$ with identifier $\beta$ have the same suffix.

As said, a branch is $[\beta, s]$. To completely store a branch
$s$ has to be put somewhere. This will be done in a file
$\mathtt{COMMIT}.\beta$ which is just a list of commits (merges
and changes) stored in reversed order that the last commit is
accessible as head of the list.

To complete a repository, a file $\mathtt{BRANCHES.}\beta$ is installed,
which contains a list of existing branches in reversed order,
i.~e. the branch created last is head of the list.
For each branch, its identifier $\beta$ ($nu$), a symbolic name
($sy$), a description ($de$) and the name of it's
\texttt{MAP}-file ($ma$) is stored.

\subsection{Case study}

This section discusses in depth a concrete example to demonstrate the
abstract model in a more implementation-close fashion.

\subsubsection{The situation}

Imagine a developer $\mathnormal{Ensel}$ (or a team of developers
if you prefer) writing
some compiler in Lisp. Later, others --
may their name be $\mathnormal{Krete}$ -- get interested in and join in.
They decide to have their own repository. The interaction of the two
repositories is presented in the following.

\subsubsection{The initial import}

$\mathnormal{Ensel}$ has written a new cool compiler from scratch
and the work done so far manifested in four Lisp-files:

\begin{verbatim}
frontend.lisp
backend.lisp
parser/grammar.lisp
parser/absy.lisp
\end{verbatim}

$\mathnormal{Ensel}$ imports these files into his repository $r$ which
now stores exactly one branch $b$ consisting of one commit $c_1$:

$r=\{[\beta, \langle c_1\rangle]\}$

Digging deeper into this structure brings to light:

\begin{itemize}
\item $[\beta, \langle c_1\rangle]\ \mbox{\textsc{isa}}\ \mathnormal{branch}$
\begin{eqnarray*}
\mathnormal{sy}\ \beta &=& \mbox{``main''} \\
\mathnormal{de}\ \beta &=& \mbox{``main line of development''} \\
\mathnormal{nu}\ \beta &=& 1 \\
\mathnormal{ma}\ \beta &=& \mathtt{MAP.1}
\end{eqnarray*}

\item $c_1\ \mbox{\textsc{isa}}\ \mathnormal{change}$ and
$c_1=[\nu_1, \beta, \alpha, f_1]$.
\begin{eqnarray*}
\mathnormal{nu}\ c_1 &=& 1 \\
\mathnormal{br}\ c_1 &=& \beta \\
\mathnormal{ac}\ c_1 &=& \mathsf{cvs} \\
\mathnormal{fi}\ c_1 &=& \left[
\begin{array}{lcl}
\mathtt{F-}a\mathtt{.1} & \mapsto & \mathsf{r1.1} \\
\mathtt{F-}b\mathtt{.1} & \mapsto & \mathsf{r1.1} \\
\mathtt{F-}c\mathtt{.1} & \mapsto & \mathsf{r1.1} \\
\mathtt{F-}d\mathtt{.1} & \mapsto & \mathsf{r1.1} \\
\mathtt{MAP.1}         & \mapsto & \mathsf{r1.1} \\
\end{array}\right] \\
\mathtt{MAP.1} &=& \left[
\begin{array}{lcl}
\mathtt{F-}a &\mapsto& \mathtt{frontend.lisp} \\
\mathtt{F-}b &\mapsto& \mathtt{backend.lisp} \\
\mathtt{F-}c &\mapsto& \mathtt{parser/grammar.lisp} \\
\mathtt{F-}d &\mapsto& \mathtt{parser/absy.lisp} \\
\end{array}\right]
\end{eqnarray*}
\end{itemize}

\subsubsection{$\mathnormal{Krete}$ joins in}

$\mathnormal{Krete}$ is enthusiastic about the new compiler
$\mathnormal{Ensel}$ has written but thinks that some basic
optimization techniques are missing and decides to implement
them. For easier access and to not clutter $\mathnormal{Ensel}$'s
repository with intermediate commits (which likely break the code)
a new repository $r'$ is installed. The first action is
$\underline{\triangledown}_1 c_1$, i.~e. to inherit the last
state of $\mathnormal{Ensel}$'s code (which is the first too at
this time\ldots).

Examination of $r'$ retrieves this information:

\begin{itemize}
\item $r=\{[\beta', \langle m'_1\rangle]\}$
\item $[\beta',\langle m'_1\rangle]\ \mbox{\textsc{isa}}\ \mathnormal{branch}$
\begin{eqnarray*}
\mathnormal{sy}\ \beta' &=& \mbox{``optimizer''} \\
\mathnormal{de}\ \beta' &=& \mbox{``includes tail-recursivion elimination''} \\
\mathnormal{nu}\ \beta' &=& 1 \\
\mathnormal{ma}\ \beta' &=& \mathtt{MAP.1}
\end{eqnarray*}

\item $m'_1\ \mbox{\textsc{isa}}\ \mathnormal{merge}$ and
$m'_1=[\nu_1, \beta', \alpha', f'_1, o'_1]$.
\begin{eqnarray*}
\mathnormal{nu}\ m'_1 &=& 1 \\
\mathnormal{br}\ m'_1 &=& \beta' \\
\mathnormal{ac}\ m'_1 &=& \mathsf{cvs} \\
\mathnormal{fi}\ m'_1 &=& \left[
\begin{array}{lcl}
\mathtt{F-}a\mathtt{.1} & \mapsto & \mathsf{r1.1} \\
\mathtt{F-}b\mathtt{.1} & \mapsto & \mathsf{r1.1} \\
\mathtt{F-}c\mathtt{.1} & \mapsto & \mathsf{r1.1} \\
\mathtt{F-}d\mathtt{.1} & \mapsto & \mathsf{r1.1} \\
\mathtt{MAP.1}         & \mapsto & \mathsf{r1.1} \\
\end{array}\right] \\
\mathnormal{oi}\ m'_1 &=& [\nu_1, \beta, \alpha] = \hat c_1 \\
\mathtt{MAP.1} &=& \left[
\begin{array}{lcl}
\mathtt{F-}a &\mapsto& \mathtt{frontend.lisp} \\
\mathtt{F-}b &\mapsto& \mathtt{backend.lisp} \\
\mathtt{F-}c &\mapsto& \mathtt{parser/grammar.lisp} \\
\mathtt{F-}d &\mapsto& \mathtt{parser/absy.lisp} \\
\end{array}\right]
\end{eqnarray*}
\end{itemize}

The optimizer code is partly performed on the Absy and partly
on the backend's intermediate language. Thus, the first change
moves the file \texttt{absy.lisp} up one level in the directory
structure to reflect that it is manipulated in the frontend
as well as in the backend. Lots of new code is inserted into
the backend to implement the optimizer.

This commit is added to $\beta'$: $c'_2=[\nu'_2, \beta', \alpha', f'_2]$
\begin{eqnarray*}
\mathnormal{nu}\ c'_2 &=& 2 \\
\mathnormal{br}\ c'_2 &=& \beta' \\
\mathnormal{ac}\ c'_2 &=& \mathsf{cvs} \\
\mathnormal{fi}\ c'_2 &=& \left[
\begin{array}{lcl}
\mathtt{F-}b\mathtt{.1} & \mapsto & \mathsf{r1.2} \\
\mathtt{MAP.1}         & \mapsto & \mathsf{r1.2} \\
\end{array}\right] \\
\mathtt{MAP.1} &=& \left[
\begin{array}{lcl}
\mathtt{F-}a &\mapsto& \mathtt{frontend.lisp} \\
\mathtt{F-}b &\mapsto& \mathtt{backend.lisp} \\
\mathtt{F-}c &\mapsto& \mathtt{parser/grammar.lisp} \\
\mathtt{F-}d &\mapsto& \mathtt{absy.lisp} \\
\end{array}\right]
\end{eqnarray*}

\subsubsection{Feedback}

The performance of the code $\mathnormal{Krete}$'s optimizer puts out is
astonishing and $\mathnormal{Ensel}$ wants to have it in to see the effect
on the language extensions he plans to include. The optimizer is
merged into the first version of the compiler: $c'_2 \rhd c_1$. This
produces merge $m_2=[\nu_2, \beta, \alpha, f_2, o_2]$.
\begin{eqnarray*}
\mathnormal{nu}\ m_2 &=& 2 \\
\mathnormal{br}\ m_2 &=& \beta' \\
\mathnormal{ac}\ m_2 &=& \mathsf{cvs} \\
\mathnormal{fi}\ m_2 &=& \left[
\begin{array}{lcl}
\mathtt{F-}b\mathtt{.1} & \mapsto & \mathsf{r1.2} \\
\mathtt{MAP.1}         & \mapsto & \mathsf{r1.2} \\
\end{array}\right] \\
\mathnormal{oi}\ m_2 &=& [\nu'_2, \beta', \alpha'] = \hat c'_2 \\
\mathtt{MAP.1} &=& \left[
\begin{array}{lcl}
\mathtt{F-}a &\mapsto& \mathtt{frontend.lisp} \\
\mathtt{F-}b &\mapsto& \mathtt{backend.lisp} \\
\mathtt{F-}c &\mapsto& \mathtt{parser/grammar.lisp} \\
\mathtt{F-}d &\mapsto& \mathtt{absy.lisp} \\
\end{array}\right]
\end{eqnarray*}

\medskip
To summarize, the repositories now have the same code and look like this:
\begin{eqnarray*}
r  &=& \{[\beta, \langle c_1, m_1\rangle]\} \\
r' &=& \{[\beta', \langle m'_1, c'_2\langle]\}
\end{eqnarray*}

\subsubsection{Branching ``locally''}

$\mathnormal{Ensel}$ decides that it is probably better to develop
the language extensions in a separate branch: $\triangledown m_2$.

His repository now contains two branches:

$r=\{[b, \langle c_1, m_2\rangle], [\beta^2, \langle m_1^2 \rangle]\}$.

Let's examine this a bit further:
\begin{itemize}
\item $[\beta^2, \langle m_1^2 \rangle\ \mbox{\textsc{isa}}\ \mathnormal{branch}$
\begin{eqnarray*}
\mathnormal{sy}\ \beta^2 &=& \mbox{``langext''} \\
\mathnormal{de}\ \beta^2 &=& \mbox{``support for sub-types based on set constraints''} \\
\mathnormal{nu}\ \beta^2 &=& 2 \\
\mathnormal{ma}\ \beta^2 &=& \mathtt{MAP.2}
\end{eqnarray*}

\item $m_1^2\ \mbox{\textsc{isa}}\ \mathnormal{merge}$ and
$m_1^2=[\nu_1^2, \beta^2, \alpha^2, f_1^2, o_1^2]$.
\begin{eqnarray*}
\mathnormal{nu}\ m'_1 &=& 1 \\
\mathnormal{br}\ m'_1 &=& \beta^2 \\
\mathnormal{ac}\ m'_1 &=& \mathsf{cvs} \\
\mathnormal{fi}\ m'_1 &=& \left[
\begin{array}{lcl}
\mathtt{F-}a\mathtt{.2} & \mapsto & \mathsf{r1.1} \\
\mathtt{F-}b\mathtt{.2} & \mapsto & \mathsf{r1.1} \\
\mathtt{F-}c\mathtt{.2} & \mapsto & \mathsf{r1.1} \\
\mathtt{F-}d\mathtt{.2} & \mapsto & \mathsf{r1.1} \\
\mathtt{MAP.2}         & \mapsto & \mathsf{r1.1} \\
\end{array}\right] \\
\mathnormal{oi}\ m_1^2 &=& [\nu_2, b, \alpha] = \hat m_2 \\
\mathtt{MAP.2} &=& \left[
\begin{array}{lcl}
\mathtt{F-}a &\mapsto& \mathtt{frontend.lisp} \\
\mathtt{F-}b &\mapsto& \mathtt{backend.lisp} \\
\mathtt{F-}c &\mapsto& \mathtt{parser/grammar.lisp} \\
\mathtt{F-}d &\mapsto& \mathtt{absy.lisp} \\
\end{array}\right]
\end{eqnarray*}
\end{itemize}

\subsubsection{Hard work\ldots}

\ldots lets the code base grow and the repositories have changed:
\begin{eqnarray*}
r &=& \{[\beta, \langle c_1, m_2\rangle], [\beta^2, \langle m_1^2, c_2^2,
c_3^2, c_4^2\rangle]\} \\
r' &=& \{[\beta', \langle m'_1, c'_2, c'_3\rangle]\}
\end{eqnarray*}

The most important changes always happen to $f$ and \texttt{MAP}.
As the next step will be merging the head from $\beta^2$ into $\beta'$
we look at $f$ and \texttt{MAP} of $c_4^2$:
\begin{eqnarray*}
\mathnormal{fi}\ c_4^2 &=& \left[
\begin{array}{lcl}
\mathtt{F-}a\mathtt{.2} & \mapsto & \mathsf{r1.1} \\
\mathtt{F-}b\mathtt{.2} & \mapsto & \mathsf{r1.1} \\
\mathtt{F-}c\mathtt{.2} & \mapsto & \mathsf{r1.1} \\
\mathtt{F-}d\mathtt{.2} & \mapsto & \mathsf{r1.2} \\
\mathtt{F-}e\mathtt{.2} & \mapsto & \mathsf{r1.2} \\
\mathtt{F-}f\mathtt{.2} & \mapsto & \mathsf{r1.3} \\
\mathtt{MAP.2}         & \mapsto & \mathsf{r1.2} \\
\end{array}\right] \\
\mathtt{MAP.2} &=& \left[
\begin{array}{lcl}
\mathtt{F-}a &\mapsto& \mathtt{frontend.lisp} \\
\mathtt{F-}b &\mapsto& \mathtt{backend.lisp} \\
\mathtt{F-}c &\mapsto& \mathtt{parser/grammar.lisp} \\
\mathtt{F-}d &\mapsto& \mathtt{absy.lisp} \\
\mathtt{F-}e &\mapsto& \mathtt{constraints/search.lisp} \\
\mathtt{F-}f &\mapsto& \mathtt{constraints/propagate.lisp} \\
\end{array}\right]
\end{eqnarray*}

Now it is time for the optimizer team to merge in the constraint solving
code to write some optimization for it: $c_4^2 \rhd c'_3$.

The result is $m'_4=[\nu'_4, \beta', \alpha', f'_4, o'_4]$ with the
following maps:
\begin{eqnarray*}
\mathnormal{fi}\ m_4 &=& \left[
\begin{array}{lcl}
\mathtt{F-}a\mathtt{.1} & \mapsto & \mathsf{r1.1} \\
\mathtt{F-}b\mathtt{.1} & \mapsto & \mathsf{r1.2} \\
\mathtt{F-}c\mathtt{.1} & \mapsto & \mathsf{r1.1} \\
\mathtt{F-}d\mathtt{.1} & \mapsto & \mathsf{r1.2} \\
\mathtt{F-}e\mathtt{.1} & \mapsto & \mathsf{r1.1} \\
\mathtt{F-}f\mathtt{.1} & \mapsto & \mathsf{r1.1} \\
\mathtt{MAP.1}         & \mapsto & \mathsf{r1.3} \\
\end{array}\right] \\
\mathtt{MAP.2} &=& \left[
\begin{array}{lcl}
\mathtt{F-}a &\mapsto& \mathtt{frontend.lisp} \\
\mathtt{F-}b &\mapsto& \mathtt{backend.lisp} \\
\mathtt{F-}c &\mapsto& \mathtt{parser/grammar.lisp} \\
\mathtt{F-}d &\mapsto& \mathtt{absy.lisp} \\
\mathtt{F-}e &\mapsto& \mathtt{constraints/search.lisp} \\
\mathtt{F-}f &\mapsto& \mathtt{constraints/propagate.lisp} \\
\end{array}\right]
\end{eqnarray*}


\subsection{Repository actions}

This section describes the basic actions branch, checkin, merge,
update in detail.

\subsubsection{Sandbox and Repository}

The sandbox the checked out copy of a certain commit
of a certain branch. The information which branch and
commit lives in the sandbox is stored in the administrative
directory.

\subsubsection{checkin}

A checkin adds a new change to a branch. Checking in is a
several step procedure:

\begin{enumerate}
\item Get the latest $\mathtt{COMMITS.}\beta$.
\item Comparison of the latest $\mathtt{COMMITS.}\beta$ with 
the one present in the sandbox gives the files changed
in the meantime from other commits.
\item Check which files are modified locally.
\item The intersection of the two file sets gives potential
conflicts. If this intersection is empty create a new commit
and prepend it to the current $\mathtt{COMMITS.}\beta$
The file map for the new commit is generated out of
the revision numbers the backend assigns to each file on
checkin.

Check in the modified $\mathtt{COMMITS.}\beta$ on throw
away the old one.
\item If the intersection is not empty check if potential
conflicts are real conflicts. (\emph{How will this be done?})
\item \emph{To be continued.}
\end{enumerate}


\subsubsection{branch}
\emph{To be written.}

\subsubsection{merge}
\emph{To be written.}

\subsubsection{update}
\emph{To be written.}

\subsection{Access identifier -- backend abstraction}
\emph{To be written.}


\section{Comments on other software}

\subsection{\textsc{dcvs}}

\textsc{dcvs} implements distributed repositories. But it assigns
responsibilities for certain parts (branches) of the code to
a particular site which is not so flexible and not what we want, I think.
They use \textsc{cvsup} to synchronize repositories which might be
interesting because the problem of how to exchange data without checking
out all necessary revisions and not touching the repository directly is
not yet solved.
 
Anyway, \textsc{dcvs} implements a concept of change sets and snapshots.
Snapshots a hooks into the code at certain point in time and change sets
are more or less diffs between to snapshots (what others call patchsets).
In our termninology, the snapshot is the change set and a patchset may
contain diffs between two or more change sets.


\section{Todo and milestones}

\subsection{Zeroth milestone}
Specification for commits (or patch sets or however). This includes
the handling of branches and merges.

\subsection{First milestone}
The first thing to do is implementing change sets and writing an
interface to the \textsc{gpgme} library. At this point, we have to decide
what \textsc{Common Lisp} implementation will be used because calls
to foreign functions is not included in the ANSI standard.
Documentation for \textsc{clisp} can be found at
\texttt{http://clisp.sourceforge.net/impnotes.html\#dffi} and the like
for \textsc{cmucl} at \texttt{http://common-lisp.net/project/cmucl/doc/cmu-user/aliens.html}.

\subsection{Other things}
\begin{itemize}
\item Switching the whole thing to use \textsc{asdf} would be great.
Furthermore, the necessity to build a Lisp image with some Unix bindings
to build the system should be removed. I think, \textsc{clisp}'s
\texttt{POSIX}-package could be sufficient.
\item \textsc{metacvs} does not support empty directories at the moment.
We could patch this.
\item The behaviour when issuing a \textsc{cvs} command not shadowed by
\textsc{metacvs} is to fire the debugger. Perhaps it is sensible to
just pass those commands to the \textsc{cvs} binary and end up in the debugger
only if the command is unknown to \textsc{cvs} too.
\item The user should not see any F-files.
\end{itemize}

\subsection{Nice features to have}

\begin{itemize}
\item An operation to gather all $\mathnormal{lsets}$s as
local copies into a repository (ending the distributiveness, perhaps
for a restart).
\item A possibility to generate a graph to show the links between
repositories.
\end{itemize}

\section{References}

\begin{itemize}
\item \texttt{http://users.footprints.net/\textasciitilde{}kaz/mcvs.html} is the home of
\textsc{metacvs}.
\item \texttt{http://www.gigamonkeys.com/book/} is a very good
\textsc{Common Lisp} book.
\item \texttt{http://clisp.cons.org/} is the home of \textsc{clisp}.
\item \texttt{http://common-lisp.net/project/slime/} is the home of
\textsc{slime}, a good interface to different \textsc{Common~Lisp}
systems for \textsc{emacs}.
\item \texttt{http://wiki.gnuarch.org/Signing\_20Archives} is the Howto of the
GNU arch project using signed archives.
\item \texttt{http://www.gnupg.org} GNU Privacy Guard.
\item \textsc{hocvs} is an extension to \textsc{metacvs} with change based
revisions. It is done with \textsc{cvs} tags, I believe, but perhaps worth a
glance. It can be found at \texttt{http://retes.hu/\textasciitilde{}mega/ho-cvs/}.
\item \textsc{dcvs} is a combination of \textsc{cvs} and \textsc{cvsup}
to support change sets and distributed repositories. It is found
at \texttt{http://www.elegosoft.com/dcvs/}.
\end{itemize}
\end{document}
