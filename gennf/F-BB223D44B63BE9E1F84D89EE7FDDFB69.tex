\documentclass[fleqn, german, 10pt, a4paper]{article}
\usepackage{babel}
\setlength{\parindent}{0pt}

\begin{document}
\title{\emph{Scratchpad}\\
{\scshape Infrastructures for Open Source Software Development}\\
Distributed Version Management System with Code Signing}
\maketitle

\tableofcontents

\section{Prologue}
This document is our project's scratchpad accompanying the development
of a distributed version management system enhanced with code signing as
part of the \emph{Infrastructures for Open Source Software Development}
course held by Steffen Evers at the Berlin Technical University.

Our hope is, that eventually the project's documentation will be
distilled out of this text. Up to that point, it will be a bit messy,
probably unstructured and a moving target of course.1

\section{Developers}
Development is currently planned to be undertaken by
\begin{itemize}
\item Fabian Otto, \texttt{sigsegv@cs.tu-berlin.de}
\item Hannes Mehnert, \texttt{mehnert@cs.tu-berlin.de}
\item Florian Lorenzen, \texttt{florenz@cs.tu-berlin.de}
\end{itemize}

\section{The goal}
We want to implement a better version management system based on
some existing software. 'Better' in this case means that it supports
code signing and distributed repositories.

Code signing means, that each chunk of code checked into the repository
has to be signed by the programmer using some public/private key scheme
to enable other developers or users to verify the origin of the code (as
long as the keys are trustworthy).

Distributed means that the repository is not stored on a single server
but that check ins can be done on several servers and the result be
merged. The advantages are a better failure behaviour and the
possibility to structure the repositories according to some external
requirements, e.~g. responsibilities for or maintenance of certain code
sections by certain parties.

Initially, we also thought about improving the code merging capabilities
which are geavily relied on in distributed environments. The idea was to
do a merge not of streams of characters (the source code) but of
abstract syntax trees of the programming language used. This seemd very
promising because fewer conflicts should arise. We abandoned this plan
for several reasons:
\begin{itemize}
\item It is language dependant: for every language used in the code at
least a context free and a regular grammar are  required. To do the
lexing and parsing a lexer- and parser-generator or some function $\phi
: G_L \rightarrow G_P \rightarrow S \rightarrow T$ with $G_L$ being a
lexer grammar, $G_P$ a parser grammar, $S$ a source code and $T$ an
abstract syntax tree would have to be implemented. This is not something
impossible but takes quite some time.
\item The algorithm to compare two abstract syntax trees is not so
trivial, at least if something better than line based diffs is supposed
to come out. Another trouble is what to consider as a conflict.
\item How to store diffs of to trees? Our idea was to store functions
$\tau : T \rightarrow T$ which transform one tree into the other. Those
function could also be used to apply the changes. At this point the
question arose if $\tau_1 \circ \tau_2 \neq \tau_2 \circ \tau_1$ could
be used as the definition of a conflict. But this is probably to simple.
Those function $\tau_i$ in turn would be compositions of atomic
transformations of one node in the tree, i.~e. a combinataion of paths
in the tree and actions to be taken at the end of the path.
\item Preserving the code layout may be a problem, even with layout
annotations in the syntax trees.
\item What to use as the storage backend? Some line based store would
not really fulfil the needs because this meant to pretty-print the
syntax tree (using the layout annotations) and to parse the last checked in
version at each commit. Consequently, the transformation function
should be stored. This in the end lead to the decision to forget about
improving the merge because the best way to do it is to write something
completely new which is too much work for one semester.
\end{itemize}

\section{The plan}
We discussed improving the handling of repositories in \textsc{darcs} or
adding distributed repositories to \textsc{metacvs}. Code Signing is not
available in any of them (at least not in our sense).

We decided to build on \textsc{metacvs} because it is, in turn, based on
\textsc{cvs} which we know quite well and because it is written in
\textsc{Common~Lisp} which makes rapid development at least possible.

In the end we would of course like to integrate our development back
into \textsc{metacvs} if convenient for the \textsc{metacvs} developers.
Hence the \ldots

\subsection{Naming issue}
For the course of development, the \emph{thing} will be called
\textsc{gennf} just to have a name (gennf is the name of the gas emitted
by the time snails in Zamonia).

\subsection{Technical stuff}
\textsc{metacvs} is implemented in \textsc{clisp} which is now installed
in \texttt{/home/pub/bin} in the IRB-network. \textsc{metacvs} is
installed in the same location to get familiar with it and for testing
purposes. \textsc{metacvs} requires \texttt{libsigsegv}, which is
installed but I had to patch the \texttt{/home/pub/bin/mcvs}-script and
the install-script to have a proper \texttt{LD\_LIBRARY\_PATH}. The
patched sources (also for \textsc{clisp}) are in \texttt{/home/pub/src}.

\textsc{slime} is installed in \texttt{/home/pub/share/emacs/slime} and
can be used by putting
\begin{verbatim}
(add-to-list 'load-path "/home/pub/share/emacs/slime")
(require 'slime)
(slime-setup)
(setq inferior-lisp-program "clisp")
\end{verbatim}

into \texttt{\textasciitilde/.emacs}.

\subsection{Communication}
Everyone participating in the project is free to mess up this file to
record relevant thoughts, ideas, \ldots.
As we are only very few people, there will probably be meetings once in
a while (see \ref{schedule} for appointments).
Day-to-day communication will be done using
\texttt{ossi@insel.cs.tu-berlin.de} with the subject \texttt{SCM:}.

There is a regular meeting tuesdays at 12 o'clock in the i-caf\'e if
not announced differently.

\subsection{Schedule \label{schedule}}
There is no real schedule yet but\ldots

\begin{tabular}{|p{.3\textwidth}|p{.6\textwidth}|}
\hline
\textmd{When} & \textmd{What} \\
\hline\hline
Nov. 7 &
Meeting at 12 o'clock in FR5017 to discuss design issues. \\
\hline
Nov. 4 to Nov. 15 &
Getting familiar with the code of \textsc{metacvs}
and drafting a design for distributiveness and signing. \\
\hline
\end{tabular}

\section{Code Signing}

\subsection{Motivation}
Currently most version management systems don't use any digital signatures
for code (apart from \textsc{tla}). Authentication is done by an own password
server (\textsc{cvs}: pserver), via a ssh public key (\textsc{cvs},
\textsc{subversion}, \textsc{darcs}, \textsc{metacvs}) or
via a digitally signed mail (\textsc{darcs}).

On the other hand, data integrity is not supported.
Every user has to trust the repository server
to be secure from a possible hacker breaking into it.
A hacker with access to the repository is able to compromise the
software by unperceived insert of a backdoor.

In the past, several big repositories have been hacked, including
KDE\footnote{http://seclists.org/lists/fulldisclosure/2004/May/0349.html},
sourceforge, jabber.org [TODO: add links].


\subsection{Vision}
A developer using \textsc{metacvs} should be able to sign his patches via
an already known-to-work and widely deployed public key cryptosystem.

An auditor should be able to look at any number of parts of the code
and sign them digitally after a successful code audit.

A user checking out the code should be able to verify the code, looking
at the different trust levels of the lines of code.
He should be able to easily spot the lines
which are least trusted according to his web of trust. If he cares much
about security, he can audit those hot spots and sign them in the repository,
becoming an auditor.

So, the trust is moved from the single point of failure (the repository
server) to every developer (able to protect his private key, or otherwise
revoke his key).

\subsection{Workflows}
A possible workflow for the developer would be that he first starts coding,
fixing a bug or implementing a new feature. When he has done with that,
during the commit he'll be asked whether he wants to sign this commit.
If he chooses to sign, he is asked for the passphrase protecting
his private key. After successfully verification of the passphrase,
the commit will be signed and transferred to the server.
Authentication could probably also be done via the signature on the code,
so no user management is anymore needed on the server, only a public keyring
including all developer keys, but possibly anyone can commit, and the user
has to choose who to trust during checkout.

A user with access to the repository checking out can verify the checked
out code, and see how safe it is.
Via \texttt{metacvs blame} he should be able to look which lines are
at which trust levels.

Via \texttt{metacvs sign} a code auditor (or user) should be able to
sign parts of code (line-, file-based).

\subsection{Implementation overview}
\begin{itemize}
\item Public key cryptography interface for \textsc{clisp}.
\item Unique patchset number, like in subversion, to match a signature to a revision.
\item Virtual patchsets describing regions in source files for auditor.
\item Decide where to store signatures.
(I think, there should be a new meta file containg the signatures, what
lines and revisions they apply to. Putting it this way audits can be handled
in the same mannner. Change and audit signatures have to distinguished by
some tag. Storeing all this in a meta file makes audit signs an
ordinary check in operation on this file -- which should be wrapped in
a nice command of course. The same applies to normal commits: they
change the F-files and make a change to the new meta file. [Florian])
\item Integration in \textsc{metacvs} commands like \texttt{commit},
\texttt{checkout}, \texttt{blame}.
\item Implement more \textsc{metacvs} commands like \texttt{verify},
\texttt{sign}.
\end{itemize}

\subsection{Implementation detail}
OpenPGP will be used as pulic key cryptosystem, because it has an
open-source implementation \textsc{gpg} (GNU Privacy Guard), is not
hierarchically structured due to the web of trust and keyserver rings.
It is also widely deployed in open source developer communities.

It has a \texttt{GnuPG Made Easy} \textsc{gpgme} development library,
which needs to be wrapped in a C-Interface for \textsc{clisp}.

The signatures has to be stored somewhere in \textsc{metacvs}, probably
in the metadata.

Some parts should be configurable for \textsc{metacvs} code signing,
a default key ID for the developer, a public keyring file for authentication
on the repository server, and possibly other things.

Probably an \textsc{emacs}-integration for \textsc{metacvs}, including the
audit-part, would be useful.


\section{Distributed repositories}

\subsection{Outline}
\emph{(Subsection probably outdated because of the model below.)}

By \emph{distributed repository} we mean support for the following
features:

\begin{itemize}
\item The possibility to build a new repository from a given a 
\textsc{metacvs} repository either by replicating the whole history or
by takeing a certain revision as new starting point -- on a per module
base of course.
\item Generation of patch sets between two given revisions (for example
\texttt{head}/\texttt{head}) of two different repositories either by pull
or push. To clarify this: Let $r_L$ be the repository of the developer
demanding a patch set and $r_R$ the partner repository. A pull patch set
is one suitable for application to $r_L$ and a push patch set is one
suitable for application to $r_R$.
There should be different methods to store and transport a patchset:
on the fly generation and application as well as saveing as an archive file
to be sent per e-mail for example.
\end{itemize}

\subsection{Technical issues}
\emph{(Subsection probably outdated because of the model below.)}

As for the code signing part unique revision numbers for each change have
to be introduced. I suggest, this will be the first thing to be done anyway.
\emph{We should agree on a sensible name for this. I suggest changeset number
to distinguish it from revision number (of a file) and patchset. A changeset
may be a patchset but has not to be necessarily.}

Generation of one repository out of another one takes part on the backend
side of the version management. The same is true for the generation
of patch sets. This means that the repository handling capabilities of
\textsc{metacvs} will probably have to be improved. It would be good if
this was possible by exclusive usage of calls to \textsc{cvs}.
They differ from most of the rest of the \texttt{metacvs} commands
because they do not affect any working copy whatsoever.

Two new commands with several options will be necessary:
\begin{itemize}
\item \texttt{inherit} to produce a new repository from some existing one,
either full blown or just of partly.
\item \texttt{create-patchset} to produce push and pull patchsets.
\end{itemize}

\subsection{Modelling distributiveness}

In the following section I propose an abstract model for distributed
repositories and their interaction. It is still incomplete
exspecially concerning sandbox-repository interaction but gives already
some implementation hints.

\subsubsection{Basic building blocks}

I propose the notion of a \emph{commit} as the basic change which can
occur to a repository.

A commit $c$ can be a \emph{change set}, \emph{link set} or
\emph{merge set}:

\begin{eqnarray*}
\mathnormal{cset} &=& (n, b, h, f) \\
\mathnormal{lset} &=& (n, b, h) \\
\mathnormal{mset} &=& (n, b, h, f, o)
\end{eqnarray*}

with $n$ being the commit number, $b$ being the \emph{branch identifier},
$h$ being the hostname where $f$, which is a mapping
$\mathnormal{file} \rightarrow \mathnormal{revision}$, is stored; $o$
is itself an $\mathnormal{lset}$.

A repository $r$ is a set of sequences of commits:

\begin{eqnarray*}
r &=& \{s\ |\ \mathnormal{commit}\ \mathnormal{list} \ \wedge \\
&&    \mathnormal{ft}\ s\ (\mathnormal{cset} \ \vee \ \mathnormal{lset}) \wedge \\
&&    \forall c_1, c_2 \in s: \mathnormal{br}\ e_1 = \mathnormal{br}\ e_2 \wedge \\
&&    \forall c \in s \ \mathnormal{rt}\ s : s\ (\mathnormal{cset} \ \vee
      \mathnormal{mset})\}
\end{eqnarray*}

The commit numbers in one repository have to be unique:

\begin{displaymath}
\forall s_1, s_2 \in r: \forall c_1 \in s_1, c_2 \in s_2: \mathnormal{nu}\ c_
\neq \mathnormal{nu}\ c_2
\end{displaymath}

Branch identifiers have to be unique as well:

\begin{displaymath}
\forall s_1, s_2 \in r: s_1 \neq s_2: \mathnormal{br}\ \mathnormal{ft}\ s_1
\neq \mathnormal{br}\ \mathnormal{ft}\ s_2
\end{displaymath}

Only one \emph{main} trunk is allowed:

\begin{displaymath}
\exists_1 s\in r : \mathnormal{ft}\ s \ \mathnormal{cset}
\end{displaymath}

Some abbreviations and helper functions are used:

\begin{itemize}
\item $\uparrow c$ denotes a commit $c'$ such that $\uparrow c = (n, b, h)$
and $c=(n, b, h, f)$.
\item $\downarrow c$ denotes a commit $c'$ such that $\downarrow
c = (n', b', h', f', o)$ with $o = \uparrow c$.
\item $\mathnormal{nu}:\ \mathnormal{commit} \rightarrow \mathnormal{number}$ \\
$\mathnormal{br}:\ \mathnormal{commit} \rightarrow \mathnormal{branch}$ \\
$\mathnormal{ho}:\ \mathnormal{commit} \rightarrow \mathnormal{hostname}$ \\
$\mathnormal{fi}:\ \mathnormal{commit} \rightarrow (\mathnormal{filename} \rightarrow \mathnormal{revision})$ \\
$\mathnormal{oi}:\ \mathnormal{commit} \rightarrow \mathnormal{commit}$
\end{itemize}

\subsubsection{Operations on repositories}

Given a repository $r = \{\langle c_1, c_2, c_3, \ldots, c_n\rangle\}$ 
important operations on repositories work like this:

\begin{itemize}
\item \emph{inherit} the whole repository:

$r' = \{\langle c'_1, c'_2, c'_3, \ldots, c'_n\rangle\}$ with
$c'_i = (n', b', h', f)$ and $c_i=(n, b, h, f)$.

\emph{inherit} parts of the repository:

$r'=\{\langle \uparrow c_k, c'_1, \ldots, c'_{n-k}\rangle \}$ with
$c'_{i-k}=(n', b', h', f)$ and $c_i=(n, b, h, f)$, $k\le n$ (if $k=n$,
$r'=\{\langle \uparrow c_n\rangle\}$, no $f$).

\item \emph{branch} from a commit $c_k$:

The resulting repository is

\begin{displaymath}
r = \{\langle c_1, \ldots, c_n\rangle, \langle \uparrow c_{k-1}, c'_1
\rangle\}, \qquad c'_1=c_k, \, k\le n
\end{displaymath}

After doing some commits to the new branch the repository looks like
this:

\begin{displaymath}
r = \{\langle c_1, \ldots, c_n\rangle, \langle \uparrow c_{k-1}, c'_1, c'_2, \ldots, c'_m
\rangle\}
\end{displaymath}

\item \emph{merge} two branches:

Merging locally looks like

\begin{displaymath}
r = \{\langle c_1^1, \ldots, c_n^1\rangle, \langle c_1^2, \ldots,
c_m^2, \downarrow c_n^1\rangle\}
\end{displaymath}

with $r=\{\langle c_1^1, \ldots, c_n^1\rangle, \langle c_1^2, \ldots,
c_m^2\}$ before the merge.

It is the same for merging between different sites except that we need two
repositories:

\begin{eqnarray*}
r_1 &=& \{\langle c_1^1, \ldots, c_n^1\rangle\} \\
r_2 &=& \{\langle c_2^1, \ldots, c_m^2\rangle\}
\end{eqnarray*}

The result of merging $c_m^2$ into the one and only branch in $r_1$ is

\begin{displaymath}
r_1 = \{\langle c_1^1, \ldots, c_n^1, \downarrow c_m^2\}
\end{displaymath}

which is the same as for local merges.
\end{itemize}

\subsection{Looking towards implementation}

Problems to be solved and questions to be answered for implementation
are

\begin{itemize}
\item Is it sensible (or even necessary) to use the branching features
of \textsc{cvs}?
\item How is the interaction between sandbox and repository? Are merge,
inherit and branch operating on the repository directly (and the result
can be enjoyed by a checkout)?
\item How is data transported between repositories? Using \textsc{cvsup}
is an option. Another option is using \textsc{remotely} which will be
slow (because many diffs have to be computed and transceived).
\item Are branch identifier factored out of sequences of commits (because
they are the same for all commits)?
\end{itemize}

The model given in the previous section already hints some implementation
details:

\begin{itemize}
\item $f$ should be implemented as a hash map.
\item Branches are sequences which can either be stored as
arrays or lists. As it is expected that most work will be done
either on all commits or the last, lists will proabbly do the job
pretty well when stored in reversed order.
\item There should be a map from hostnames to some identifier because
hostnames (and paths of \textsc{cvs} repositories) may change.
\item Commits and $\mathrm{[lmc]set}$s will be classes and
branches sequences of instances of these classes.
\end{itemize}

\subsection{Nice features to have}

\begin{itemize}
\item An operation to gather all $\mathnormal{lsets}$s as
local copies into a repository (ending the distributiveness, perhaps
for a restart).
\item A possibility to generate a graph to show the links between
repositories.
\end{itemize}

\section{Comments on other software}

\subsection{\textsc{dcvs}}

\textsc{dcvs} implements distributed repositories. But it assigns
responsibilities for certain parts (branches) of the code to
a particular site which is not so flexible and not what we want, I think.
They use \textsc{cvsup} to synchronize repositories which might be
interesting because the problem of how to exchange data without checking
out all necessary revisions and not touching the repository directly is
not yet solved.
 
Anyway, \textsc{dcvs} implements a concept of change sets and snapshots.
Snapshots a hooks into the code at certain point in time and change sets
are more or less diffs between to snapshots (what others call patchsets).
In our termninology, the snapshot is the change set and a patchset may
contain diffs between two or more change sets.


\section{Todo and milestones}

\subsection{Zeroth milestone}
Specification for commits (or patch sets or however). This includes
the handling of branches and merges.

\subsection{First milestone}
The first thing to do is implementing change sets and writing an
interface to the \textsc{gpgme} library. At this point, we have to decide
what \textsc{Common Lisp} implementation will be used because calls
to foreign functions is not included in the ANSI standard.
Documentation for \textsc{clisp} can be found at
\texttt{http://clisp.sourceforge.net/impnotes.html\#dffi} and the like
for \textsc{cmucl} at \texttt{http://common-lisp.net/project/cmucl/doc/cmu-user/aliens.html}.

\subsection{Other things}
\begin{itemize}
\item \textsc{metacvs} does not support empty directories at the moment.
We could patch this.
\item The behaviour when issuing a \textsc{cvs} command not shadowed by
\textsc{metacvs} is to fire the dbeugger. Perhaps it is sensible to
just pass those commands to the \textsc{cvs} binary and end up in the debugger
only if the command is unknown to \textsc{cvs} too.
\end{itemize}

\section{Logbook}

This section is intended to contain short notes of changes done to the
project, be it commits to the code base or adding content to this o
other describtive files.

\subsubsection*{November 24, 2005}
Added this section to the scratchpad and a to do list and milestos

Removed the \textsc{metacvs} sources from our repository. The reason is
that it is bad style to store someone else's complete tree when not forking.
Maybe, the project evolves into a fork but at the moment a patch is
intended.

Wrote some comment on \textsc{dcvs}.\hfill{\textit{florenz}}


\subsubsection*{November 29, 2005}

Written a first specification for the distributiveness along with some
very basic implementation hints.\hfill{\textit{florenz}}


\subsection*{December 2, 2005}

Enabled commit mails. First tried syncmail but this script includes
diffs in the mails which is not really necessary. Replaced it with
log_accum.pl from the octopus-project (\texttt{http://www.tddft.org})
which is originally from FreeBSD.\hfill{\textit{florenz}}

\section{References}

\begin{itemize}
\item \texttt{http://users.footprints.net/\textasciitilde{}kaz/mcvs.html} is the home of
\textsc{metacvs}.
\item \texttt{http://www.gigamonkeys.com/book/} is a very good
\textsc{Common Lisp} book.
\item \texttt{http://clisp.cons.org/} is the home of \textsc{clisp}.
\item \texttt{http://common-lisp.net/project/slime/} is the home of
\textsc{slime}, a good interface to different \textsc{Common~Lisp}
systems for \textsc{emacs}.
\item \texttt{http://wiki.gnuarch.org/Signing\_20Archives} is the Howto of the
GNU arch project using signed archives
\item \texttt{http://www.gnupg.org} GNU Privacy Guard
\item \textsc{hocvs} is an extension to \textsc{metacvs} with change based
revisions. It is done with \textsc{cvs} tags, I believe, but perhaps worth a
glance. It can be found at \texttt{http://retes.hu/\textasciitilde{}mega/ho-cvs/}.
\item \textsc{dcvs} is a combination of \textsc{cvs} and \textsc{cvsup}
to support change sets and distributed repositories. It is found
at \texttt{http://www.elegosoft.com/dcvs/}.
\end{itemize}
\end{document}
